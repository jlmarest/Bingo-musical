<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <title>Bingo musical (Spotify Web Playback SDK + PKCE)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 20px; }
    h1 { margin-top: 0; }
    label { display:block; margin:6px 0; }
    input { width: 100%; max-width: 560px; padding:8px; }
    button { padding: 10px 16px; margin: 8px 6px 8px 0; }
    pre { background:#f5f5f5; padding:10px; max-height:260px; overflow:auto; white-space:pre-wrap; }
    small { color:#555; }
  </style>
</head>
<body>
  <h1>Bingo musical</h1>

  <label>Client ID de Spotify:
    <input id="clientId" placeholder="tu_client_id">
  </label>
  <label>Redirect URI:
    <input id="redirectUri" placeholder="https://jlmarest.github.io/Bingo-musical/">
  </label>
  <button id="loginBtn">Iniciar sesión en Spotify</button>

  <label>Playlist ID (spotify:playlist:... o URL):
    <input id="playlistId" placeholder="https://open.spotify.com/playlist/XXXXXXXXXXXXXX">
  </label>
  <input type="file" id="segmentsCsv" accept=".csv"/>
  <small>(Opcional) CSV con segmentos: track_id,start_sec,end_sec</small>
  <div>
    <button id="loadPlaylistBtn">Cargar playlist</button>
    <button id="startBingoBtn">Empezar bingo</button>
    <button id="downloadLogBtn">Descargar log (CSV)</button>
  </div>

  <div>
    <button id="activateAudioBtn">Activar audio (si no suena)</button>
    <button id="useThisDeviceBtn">Usar este dispositivo</button>
    <button id="listarDevicesBtn">Listar dispositivos</button>
  </div>

  <pre id="log"></pre>

  <!-- Tu app: define TODO antes de cargar el SDK -->
  <script>
    /**********************
     * CONFIG POR DEFECTO *
     **********************/
    const DEFAULT_CLIENT_ID = 'f19b2716d1bb46ba98f7ff7c5bf3656c'
    const DEFAULT_REDIRECT_URI = 'https://jlmarest.github.io/Bingo-musical/';
    const PLAYER_NAME = 'Bingo musical';

    /*****************
     * ESTADO GLOBAL *
     *****************/
    let token = null;
    let refreshToken = null;
    let tokenExpiry = 0;
    let deviceId = null;
    let player = null;
    let tracks = [];
    let segments = {};
    let logRows = [];

    const SCOPES = [
      'streaming',
      'user-read-email',
      'user-read-private',
      'playlist-read-private',
      'playlist-read-collaborative',
      'user-modify-playback-state',
      'user-read-playback-state'
    ];

    const logEl = document.getElementById('log');
    function appendLog(msg) { logEl.textContent += msg + "\n"; }

    function getClientId(){ return (document.getElementById('clientId').value.trim() || DEFAULT_CLIENT_ID); }
    function getRedirectUri(){ return (document.getElementById('redirectUri').value.trim() || DEFAULT_REDIRECT_URI); }
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    /**************
     * PKCE OAuth *
     **************/
    function base64urlencode(arrayBuffer) {
      let str = btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));
      return str.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    async function sha256(plain) {
      const enc = new TextEncoder().encode(plain);
      const digest = await crypto.subtle.digest('SHA-256', enc);
      return digest;
    }
    function randomString(len=64){
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let out = '';
      const arr = new Uint32Array(len);
      crypto.getRandomValues(arr);
      for (let i=0;i<len;i++) out += chars[arr[i] % chars.length];
      return out;
    }
    function saveAuthState(obj){ sessionStorage.setItem('auth_state', JSON.stringify(obj)); }
    function readAuthState(){ try{ return JSON.parse(sessionStorage.getItem('auth_state')||'{}'); }catch{ return {} } }

    async function ensureTokenValid(){
      if (!token) return;
      const now = Date.now();
      if (now < tokenExpiry - 5000) return;
      if (!refreshToken) return;
      const params = new URLSearchParams();
      params.set('grant_type','refresh_token');
      params.set('refresh_token', refreshToken);
      params.set('client_id', getClientId());
      const res = await fetch('https://accounts.spotify.com/api/token', {
        method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
        body: params.toString()
      });
      if (!res.ok){ appendLog('Error al refrescar token: ' + res.status); return; }
      const data = await res.json();
      token = data.access_token;
      tokenExpiry = Date.now() + (data.expires_in * 1000);
      saveAuthState({ token, refreshToken, tokenExpiry });
      appendLog('Token renovado.');
    }

    async function startLogin(){
      const clientId = getClientId();
      const redirectUri = getRedirectUri();
      const codeVerifier = randomString(64);
      const codeChallenge = base64urlencode(await sha256(codeVerifier));
      const state = randomString(16);
      saveAuthState({ codeVerifier, state });
      const params = new URLSearchParams({
        client_id: clientId,
        response_type: 'code',
        redirect_uri: redirectUri,
        code_challenge_method: 'S256',
        code_challenge: codeChallenge,
        scope: SCOPES.join(' '),
        state
      });
      window.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
    }

    async function handleRedirectBack(){
      const url = new URL(window.location.href);
      const code = url.searchParams.get('code');
      const returnedState = url.searchParams.get('state');
      const error = url.searchParams.get('error');
      if (error){ appendLog('Error OAuth: '+error); return; }
      if (!code) return;

      const { codeVerifier, state } = readAuthState();
      if (!codeVerifier || state !== returnedState){ appendLog('Estado OAuth inválido.'); return; }

      const params = new URLSearchParams();
      params.set('grant_type','authorization_code');
      params.set('code', code);
      params.set('redirect_uri', getRedirectUri());
      params.set('client_id', getClientId());
      params.set('code_verifier', codeVerifier);

      const res = await fetch('https://accounts.spotify.com/api/token', {
        method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
        body: params.toString()
      });
      if (!res.ok){ appendLog('Error token endpoint: '+res.status); return; }

      const data = await res.json();
      token = data.access_token;
      refreshToken = data.refresh_token || null;
      tokenExpiry = Date.now() + (data.expires_in * 1000);
      saveAuthState({ token, refreshToken, tokenExpiry });
      appendLog('Autenticado.');

      // limpia la query
      history.replaceState({}, document.title, window.location.pathname);
    }

    /**********************
     * CARGA DEL SDK (OK) *
     **********************/
    // Definimos el callback ANTES de insertar el script del SDK
    window.onSpotifyWebPlaybackSDKReady = () => {
      appendLog('SDK cargado.');
      initPlayer();
    };

    function loadSpotifySDK(){
      if (document.getElementById('spotify-sdk')) return;
      const s = document.createElement('script');
      s.id = 'spotify-sdk';
      s.src = 'https://sdk.scdn.co/spotify-player.js';
      s.onload = () => { /* el SDK llamará a onSpotifyWebPlaybackSDKReady */ };
      s.onerror = () => appendLog('Error cargando el SDK de Spotify.');
      document.body.appendChild(s);
    }

    function initPlayer(){
      if (!token){ appendLog('Aún no hay token; inicia sesión primero.'); return; }

      player = new Spotify.Player({
        name: PLAYER_NAME,
        getOAuthToken: async cb => { await ensureTokenValid(); cb(token); },
        volume: 1.0
      });

      player.addListener('ready', async ({ device_id }) => {
        deviceId = device_id;
        appendLog('Dispositivo listo: ' + deviceId);
        try { if (player.activateElement) await player.activateElement(); } catch {}
        await transferPlayback(true); // “despierta” y fija este dispositivo
        // Diagnóstico: lista dispositivos
        try { await listarDispositivos(); } catch {}
      });

      player.addListener('not_ready', ({ device_id }) => {
        appendLog('Dispositivo offline: ' + device_id);
        if (deviceId === device_id) deviceId = null;
      });

      player.addListener('initialization_error', ({ message }) => appendLog('Init error: ' + message));
      player.addListener('authentication_error', ({ message }) => appendLog('Auth error: ' + message));
      player.addListener('account_error', ({ message }) => appendLog('Account error: ' + message));
      player.addListener('playback_error', ({ message }) => appendLog('Playback error: ' + message));

      player.addListener('player_state_changed', (state) => {
        if (!state){ appendLog('Estado: null (SDK no activo)'); return; }
        const t = state.track_window.current_track;
        appendLog(`Estado: ${state.paused ? 'Pausa':'Reproduciendo'} — ${t?.name ?? '(sin pista)'}`);
      });

      player.connect().then(ok => appendLog('player.connect() => ' + ok));
    }

    /*****************
     * API genérica  *
     *****************/
    async function api(path, method='GET', body=null) {
      await ensureTokenValid();
      const res = await fetch(
        path.startsWith('http') ? path : `https://api.spotify.com/v1/${path}`,
        { method, headers:{ 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: body ? JSON.stringify(body) : null }
      );
      if (!res.ok) throw new Error(`${path} => ${res.status}`);
      return res.json();
    }

    async function tryFetch(url, options, retries=3, backoff=500){
      for (let i=0;i<retries;i++){
        try{
          const res = await fetch(url, options);
          if (res.ok) return res;
          appendLog(`Fetch fallo (${res.status}) en ${url}, intento ${i+1}/${retries}`);
        }catch(e){
          appendLog(`Fetch error en ${url}: ${e.message} (intento ${i+1}/${retries})`);
        }
        await sleep(backoff*(i+1));
      }
      throw new Error('Failed to fetch: ' + url);
    }

    async function listarDispositivos(){
      const data = await api('me/player/devices');
      const resumen = data.devices.map(d => `${d.name} [${d.type}] activo=${d.is_active} (id=${d.id})`).join(' | ');
      appendLog('Dispositivos: ' + resumen);
      return data.devices;
    }

    async function discoverSdkDeviceIdByName(name = PLAYER_NAME){
      const devices = await listarDispositivos();
      const sdk = devices.find(d => d.name === name);
      if (sdk){ deviceId = sdk.id; appendLog('SDK device descubierto por API: ' + deviceId); return true; }
      appendLog('SDK device no aparece en la lista.');
      return false;
    }

    async function transferPlayback(playNow=false){
      await ensureTokenValid();
      if (!deviceId){
        appendLog('No hay deviceId: intentando descubrirlo por API…');
        const ok = await discoverSdkDeviceIdByName(PLAYER_NAME);
        if (!ok){ appendLog('Transfer cancelado: sin deviceId.'); return; }
      }
      const res = await fetch('https://api.spotify.com/v1/me/player', {
        method:'PUT',
        headers:{ 'Authorization': `Bearer ${token}`, 'Content-Type':'application/json' },
        body: JSON.stringify({ device_ids: [deviceId], play: !!playNow })
      });
      if (res.ok) appendLog('Playback transferido al Web Player (SDK).');
      else appendLog('Transfer playback error: ' + res.status);
    }

    async function isSdkActive(){
      try { const st = await player.getCurrentState(); return !!st; } catch { return false; }
    }

    async function playTrackUri(uri){
      await ensureTokenValid();
      const useSDK = await isSdkActive() && !!deviceId;
      const qp = useSDK ? `?device_id=${deviceId}` : '';
      await tryFetch(`https://api.spotify.com/v1/me/player/play${qp}`, {
        method:'PUT',
        headers:{ 'Authorization': `Bearer ${token}`, 'Content-Type':'application/json' },
        body: JSON.stringify({ uris:[uri] })
      }, 3, 500);
    }

    async function seekPosition(ms){
      await ensureTokenValid();
      const useSDK = await isSdkActive() && !!deviceId;
      const url = `https://api.spotify.com/v1/me/player/seek?position_ms=${ms}` + (useSDK ? `&device_id=${deviceId}` : '');
      await tryFetch(url, { method:'PUT', headers:{ 'Authorization': `Bearer ${token}` } }, 2, 500);
    }

    function parsePlaylistId(input){
      const v = (input||'').trim();
      try{
        if (v.includes('playlist')){
          const u = new URL(v);
          const parts = u.pathname.split('/');
          const idx = parts.findIndex(p => p==='playlist');
          if (idx>=0 && parts[idx+1]) return parts[idx+1];
        }
      }catch{}
      return v;
    }

    async function loadPlaylist(){
      if (!token){ appendLog('No estás autenticado.'); return; }
      tracks = [];
      const pid = parsePlaylistId(document.getElementById('playlistId').value);
      appendLog('Cargando playlist: ' + pid);

      let url = `https://api.spotify.com/v1/playlists/${pid}/tracks?fields=items(track(id,name,artists(name),uri)),next&limit=100`;
      while (url){
        await ensureTokenValid();
        const res = await fetch(url, { headers:{ 'Authorization': `Bearer ${token}` } });
        if (!res.ok) throw new Error(`API ${url} => ${res.status}`);
        const data = await res.json();
        for (const item of data.items){
          if (item.track && item.track.id){
            tracks.push({
              id: item.track.id,
              name: item.track.name,
              artists: item.track.artists.map(a=>a.name).join(', '),
              uri: `spotify:track:${item.track.id}`
            });
          }
        }
        url = data.next;
      }
      appendLog(`Total pistas: ${tracks.length}`);

      // CSV opcional
      const file = document.getElementById('segmentsCsv').files[0];
      segments = {};
      if (file){
        const text = await file.text();
        for (const line of text.split(/\r?\n/)){
          const [tid, start, end] = line.split(',');
          if (tid && start && end) segments[tid.trim()] = { start:+start, end:+end };
        }
        appendLog(`Segmentos cargados: ${Object.keys(segments).length}`);
      }else{
        appendLog('Sin CSV: se usarán fragmentos simulados (15s desde 45s).');
      }

      // activa este dispositivo (si no lo está)
      await transferPlayback(true);
    }

    function shuffle(a){
      const r = a.slice();
      for (let i=r.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [r[i],r[j]]=[r[j],r[i]]; }
      return r;
    }

    async function startBingo(){
      if (!tracks.length){ appendLog('No hay pistas cargadas.'); return; }
      const order = shuffle(tracks);

      for (const t of order){
        const seg = segments[t.id] || { start:45, end:60 }; // 15s desde 00:45
        const startSec = seg.start, endSec = seg.end;

        appendLog(`▶ ${t.name} — ${t.artists} [${startSec}s → ${endSec}s]`);
        await playTrackUri(t.uri);
        await sleep(1200);
        await seekPosition(startSec * 1000);


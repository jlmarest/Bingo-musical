<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <title>Bingo musical (Spotify Web Playback SDK + PKCE)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 20px; }
    h1 { margin-top: 0; }
    label { display:block; margin:6px 0; }
    input { width: 100%; max-width: 560px; padding:8px; }
    button { padding: 10px 16px; margin: 8px 6px 8px 0; }
    pre { background:#f5f5f5; padding:10px; max-height:300px; overflow:auto; white-space:pre-wrap; }
    small { color:#555; }
  </style>
</head>
<body>
  <h1>Bingo musical</h1>

  <label>Client ID de Spotify:
    <input id="clientId" placeholder="tu_client_id">
  </label>
  <label>Redirect URI:
    <input id="redirectUri" placeholder="https://jlmarest.github.io/Bingo-musical/">
  </label>
  <button id="loginBtn">Iniciar sesión en Spotify</button>

  <label>Playlist ID (spotify:playlist:... o URL):
    <input id="playlistId" placeholder="https://open.spotify.com/playlist/XXXXXXXXXXXXXX">
  </label>
  <input type="file" id="segmentsCsv" accept=".csv"/>
  <small>(Opcional) CSV con segmentos: track_id,start_sec,end_sec</small>
  <div>
    <button id="loadPlaylistBtn">Cargar playlist</button>
    <button id="genCsvBtn">Generar CSV de segmentos (aleatorio)</button>
    <button id="validarCsvBtn">Validar segmentos CSV</button>
  </div>
  <div>
    <button id="startBingoBtn">Empezar bingo</button>
    <button id="pauseBingoBtn">Pausar bingo</button>
    <button id="resumeBingoBtn">Reanudar bingo</button>
  </div>

  <div>
    <button id="activateAudioBtn">Activar audio (si no suena)</button>
    <button id="useThisDeviceBtn">Usar este dispositivo</button>
    <button id="listarDevicesBtn">Listar dispositivos</button>
  </div>
  <div>
    <button id="stopBingoBtn">Detener bingo</button>
    <button id="downloadLogBtn">Descargar log (CSV)</button>
  </div>

  <pre id="log"></pre>

  <script>
    /**********************
     * CONFIG POR DEFECTO *
     **********************/
    const DEFAULT_CLIENT_ID = 'f19b2716d1bb46ba98f7ff7c5bf3656c';  // puedes cambiarlo si quieres
    const DEFAULT_REDIRECT_URI = 'https://jlmarest.github.io/Bingo-musical/'; // debe coincidir 1:1 con Spotify App
    const PLAYER_NAME = 'Bingo musical';

    /*****************
     * ESTADO GLOBAL *
     *****************/
    let token = null;
    let refreshToken = null;
    let tokenExpiry = 0;
    let deviceId = null;
    let player = null;
    let tracks = [];
    let segments = {};
    let logRows = [];
    
    // Estado del bingo para pausar/reanudar
    let bingoRunning = false;
    let bingoPaused = false;
    let currentTrack = null;           // { id, name, artists, uri }
    let currentSeg = null;             // { start, end }
    let remainingMs = 0;               // milisegundos que faltan del fragmento en curso
    let pauseStartedAt = null;         // timestamp cuando pausamos
    

    const SCOPES = [
      'streaming',
      'user-read-email',
      'user-read-private',
      'playlist-read-private',
      'playlist-read-collaborative',
      'user-modify-playback-state',
      'user-read-playback-state'
    ];

    const logEl = document.getElementById('log');
    function appendLog(msg) { logEl.textContent += msg + "\n"; }
    function getClientId(){ return (document.getElementById('clientId').value.trim() || DEFAULT_CLIENT_ID); }
    function getRedirectUri(){ return (document.getElementById('redirectUri').value.trim() || DEFAULT_REDIRECT_URI); }
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    /**************
     * PKCE OAuth *
     **************/
    function base64urlencode(arrayBuffer) {
      let str = btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));
      return str.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    async function sha256(plain) {
      const enc = new TextEncoder().encode(plain);
      const digest = await crypto.subtle.digest('SHA-256', enc);
      return digest;
    }
    function randomString(len=64){
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let out = '';
      const arr = new Uint32Array(len);
      crypto.getRandomValues(arr);
      for (let i=0;i<len;i++) out += chars[arr[i] % chars.length];
      return out;
    }
    function saveAuthState(obj){ sessionStorage.setItem('auth_state', JSON.stringify(obj)); }
    function readAuthState(){ try{ return JSON.parse(sessionStorage.getItem('auth_state')||'{}'); }catch{ return {} } }

    async function ensureTokenValid(){
      if (!token) return;
      const now = Date.now();
      if (now < tokenExpiry - 5000) return;
      if (!refreshToken) return;
      const params = new URLSearchParams();
      params.set('grant_type','refresh_token');
      params.set('refresh_token', refreshToken);
      params.set('client_id', getClientId());
      const res = await fetch('https://accounts.spotify.com/api/token', {
        method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
        body: params.toString()
      });
      if (!res.ok){ appendLog('Error al refrescar token: ' + res.status); return; }
      const data = await res.json();
      token = data.access_token;
      tokenExpiry = Date.now() + (data.expires_in * 1000);
      saveAuthState({ token, refreshToken, tokenExpiry });
      appendLog('Token renovado.');
    }

    async function startLogin(){
      const clientId = getClientId();
      const redirectUri = getRedirectUri();
      const codeVerifier = randomString(64);
      const codeChallenge = base64urlencode(await sha256(codeVerifier));
      const state = randomString(16);
      saveAuthState({ codeVerifier, state });
      const params = new URLSearchParams({
        client_id: clientId,
        response_type: 'code',
        redirect_uri: redirectUri,
        code_challenge_method: 'S256',
        code_challenge: codeChallenge,
        scope: SCOPES.join(' '),
        state
      });
      window.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
    }

    async function handleRedirectBack(){
      const url = new URL(window.location.href);
      const code = url.searchParams.get('code');
      const returnedState = url.searchParams.get('state');
      const error = url.searchParams.get('error');
      if (error){ appendLog('Error OAuth: '+error); return; }
      if (!code) return;

      const { codeVerifier, state } = readAuthState();
      if (!codeVerifier || state !== returnedState){ appendLog('Estado OAuth inválido.'); return; }

      const params = new URLSearchParams();
      params.set('grant_type','authorization_code');
      params.set('code', code);
      params.set('redirect_uri', getRedirectUri());
      params.set('client_id', getClientId());
      params.set('code_verifier', codeVerifier);

      const res = await fetch('https://accounts.spotify.com/api/token', {
        method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
        body: params.toString()
      });
      if (!res.ok){ appendLog('Error token endpoint: '+res.status); return; }

      const data = await res.json();
      token = data.access_token;
      refreshToken = data.refresh_token || null;
      tokenExpiry = Date.now() + (data.expires_in * 1000);
      saveAuthState({ token, refreshToken, tokenExpiry });
      appendLog('Autenticado.');

      // Limpia la query para evitar repetir el canje al refrescar
      history.replaceState({}, document.title, window.location.pathname);
    }

    /**********************
     * CARGA DEL SDK (OK) *
     **********************/
    // Definir el callback ANTES de cargar el script del SDK
    window.onSpotifyWebPlaybackSDKReady = () => {
      appendLog('SDK cargado.');
      initPlayer();
    };

    function initPlayer(){
      if (!token){ appendLog('Aún no hay token; inicia sesión primero.'); return; }
      player = new Spotify.Player({
        name: PLAYER_NAME,
        getOAuthToken: async cb => { await ensureTokenValid(); cb(token); },
        volume: 1.0
      });

      player.addListener('ready', async ({ device_id }) => {
        deviceId = device_id;
        appendLog('Dispositivo listo: ' + deviceId);
        try { if (player.activateElement) await player.activateElement(); } catch {}
        await transferPlayback(true); // fija este dispositivo como destino
        try { await listarDispositivos(); } catch {}
      });

      player.addListener('not_ready', ({ device_id }) => {
        appendLog('Dispositivo offline: ' + device_id);
        if (deviceId === device_id) deviceId = null;
      });

      player.addListener('initialization_error', ({ message }) => appendLog('Init error: ' + message));
      player.addListener('authentication_error', ({ message }) => appendLog('Auth error: ' + message));
      player.addListener('account_error', ({ message }) => appendLog('Account error: ' + message));
      player.addListener('playback_error', ({ message }) => appendLog('Playback error: ' + message));

      player.addListener('player_state_changed', (state) => {
        if (!state){ appendLog('Estado: null (SDK no activo)'); return; }
        const t = state.track_window.current_track;
        appendLog(`Estado: ${state.paused ? 'Pausa':'Reproduciendo'} — ${t?.name ?? '(sin pista)'}`);
      });

      player.connect().then(ok => appendLog('player.connect() => ' + ok));
    }

    /*****************
     * API genérica  *
     *****************/
    async function api(path, method='GET', body=null) {
      await ensureTokenValid();
      const res = await fetch(
        path.startsWith('http') ? path : `https://api.spotify.com/v1/${path}`,
        { method, headers:{ 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: body ? JSON.stringify(body) : null }
      );
      if (!res.ok) throw new Error(`${path} => ${res.status}`);
      return res.json();
    }

    async function tryFetch(url, options, retries=3, backoff=500){
      for (let i=0;i<retries;i++){
        try{
          const res = await fetch(url, options);
          if (res.ok) return res;
          appendLog(`Fetch fallo (${res.status}) en ${url}, intento ${i+1}/${retries}`);
        }catch(e){
          appendLog(`Fetch error en ${url}: ${e.message} (intento ${i+1}/${retries})`);
        }
        await sleep(backoff*(i+1));
      }
      throw new Error('Failed to fetch: ' + url);
    }

    async function listarDispositivos(){
      const data = await api('me/player/devices');
      const resumen = data.devices.map(d => `${d.name} [${d.type}] activo=${d.is_active} (id=${d.id})`).join(' | ');
      appendLog('Dispositivos: ' + resumen);
      return data.devices;
    }


    // Elige el mejor dispositivo disponible: primero SDK (si existiera),
    // si no, Web Player (Chrome/Edge), si no, cualquiera activo; si no, el primero.

    async function chooseBestDevice() {
      await ensureTokenValid();
      const data = await api('me/player/devices');
      const devices = data.devices || [];

      // 1) Intentar SDK por nombre (si algún día aparece)
      let d = devices.find(x => x.name === PLAYER_NAME);

      // 2) Si no, preferir Web Player (Chrome/Edge)
      if (!d) d = devices.find(x => /Web Player/i.test(x.name));

      // 3) Si no, cualquier activo
      if (!d) d = devices.find(x => x.is_active);

      // 4) Si no, el primero disponible
      if (!d) d = devices[0];

      if (!d) {
        appendLog('No hay dispositivos disponibles en tu cuenta.');
        return false;
      }
      deviceId = d.id;
      appendLog(`Destino elegido: ${d.name} [${d.type}] activo=${d.is_active} (id=${d.id})`);
      return true;
    }

    async function transferPlayback(playNow = false) {
      await ensureTokenValid();
      if (!deviceId) {
        const ok = await chooseBestDevice();
        if (!ok) { appendLog('Transfer cancelado: sin deviceId.'); return; }
      }
      const res = await fetch('https://api.spotify.com/v1/me/player', {
        method: 'PUT',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ device_ids: [deviceId], play: !!playNow })
      });
      if (res.ok) appendLog('Playback transferido al dispositivo elegido.');
      else appendLog('Transfer playback error: ' + res.status);
    }



    async function isSdkActive(){
      try { const st = await player.getCurrentState(); return !!st; } catch { return false; }
    }


    async function playTrackUri(uri) {
      await ensureTokenValid();
      if (!deviceId) { const ok = await chooseBestDevice(); if (!ok) return; }
      await tryFetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
        method: 'PUT',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ uris: [uri] })
      }, 3, 500);
    }

    async function seekPosition(ms) {
      await ensureTokenValid();
      if (!deviceId) { const ok = await chooseBestDevice(); if (!ok) return; }
      await tryFetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${ms}&device_id=${deviceId}`, {
        method: 'PUT',
        headers: { 'Authorization': `Bearer ${token}` }
      }, 2, 500);
    }


    function sleepPausable(ms) {
      return new Promise(async (resolve) => {
        let elapsed = 0;
        const step = 200; // chequeo cada 200 ms
        while (elapsed < ms) {
          if (bingoPaused) {
            // Esperar hasta que se reanude
            await new Promise(r => {
              const check = () => {
                if (!bingoPaused) r();
                else setTimeout(check, 200);
              };
              check();
            });
          }
          const chunk = Math.min(step, ms - elapsed);
          await sleep(chunk);
          elapsed += chunk;
          remainingMs = ms - elapsed;
        }
        resolve();
      });
    }


    function parsePlaylistId(input) {
      const v = (input || '').trim();
      if (!v) return '';
      try {
        // Caso URL: https://open.spotify.com/playlist/<ID>?...
        if (v.includes('open.spotify.com/playlist/')) {
          const u = new URL(v);
          const parts = u.pathname.split('/');
          const idx = parts.findIndex(p => p === 'playlist');
          if (idx >= 0 && parts[idx + 1]) return parts[idx + 1];
          return '';
        }
        // Caso URI: spotify:playlist:<ID>
        if (v.startsWith('spotify:playlist:')) {
          return v.split(':')[2] || '';
        }
      } catch (e) {
        // Si no es URL válida, caeremos a "ID simple"
      }
      // Caso ID simple
      return v;
    }

    // Normaliza una celda CSV: quita BOM, comillas y espacios
    function normalizeCell(s) {
      if (!s) return '';
      return s
        .replace(/^\uFEFF/, '')      // BOM
        .replace(/^"+|"+$/g, '')     // comillas al inicio/fin
        .trim();
    }
    
    async function loadPlaylist() {
      if (!token) { appendLog('No estás autenticado.'); return; }
    
      const pid = parsePlaylistId(document.getElementById('playlistId').value);
      if (!pid) { appendLog('Playlist ID vacío o inválido.'); return; }
    
      tracks = [];
      appendLog('Cargando playlist: ' + pid);
    
      // OJO: duration_ms para generar y validar segmentos
      let url = `https://api.spotify.com/v1/playlists/${pid}/tracks?fields=items(track(id,name,artists(name),uri,duration_ms)),next&limit=100`;
      while (url) {
        await ensureTokenValid();
        const res = await fetch(url, { headers: { 'Authorization': `Bearer ${token}` } });
        if (!res.ok) throw new Error(`API ${url} => ${res.status}`);
        const data = await res.json();
        for (const item of data.items) {
          const t = item.track;
          if (t && t.id) {
            tracks.push({
              id: t.id,
              name: t.name,
              artists: (t.artists || []).map(a => a.name).join(', '),
              uri: `spotify:track:${t.id}`,
              duration_ms: t.duration_ms || null
            });
          }
        }
        url = data.next;
      }
      appendLog(`Total pistas: ${tracks.length}`);
    
      // === Leer CSV de segmentos (opcional) ===
      segments = {};
      const file = document.getElementById('segmentsCsv').files?.[0];
      if (file) {
        const text = await file.text();
        const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
    
        // Detectar encabezado
        let startIdx = 0;
        const header = lines[0].split(',').map(normalizeCell);
        const hasHeader = header[0].toLowerCase() === 'track_id';
        if (hasHeader) startIdx = 1;
    
        let totalCsvRows = 0;
        for (let i = startIdx; i < lines.length; i++) {
          const cols = lines[i].split(',').map(normalizeCell);
          const [tid, start, end] = cols;
          if (!tid || !start || !end) continue;
          const startNum = Number(start);
          const endNum = Number(end);
          if (!Number.isFinite(startNum) || !Number.isFinite(endNum)) continue;
          segments[tid] = { start: startNum, end: endNum };
          totalCsvRows++;
        }
    
        // Diagnóstico: cuántos segmentos del CSV aplican a pistas cargadas
        const trackIds = new Set(tracks.map(t => t.id));
        const matched = Object.keys(segments).filter(id => trackIds.has(id)).length;
    
        appendLog(`Segmentos CSV: ${totalCsvRows} filas; coinciden con playlist: ${matched}`);
        if (matched === 0) {
          appendLog('⚠ Ningún track_id del CSV coincide. Comprueba que el CSV usa IDs como "3n3Ppam7..." y no URLs.');
        }
      } else {
        appendLog('Sin CSV: se usarán fragmentos simulados (15s desde 45s).');
      }
    
      // Activa/elige dispositivo destino
      await transferPlayback(true);
    }


    function shuffle(a){
      const r = a.slice();
      for (let i=r.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [r[i],r[j]]=[r[j],r[i]]; }
      return r;
    }


    async function startBingo(){
      if (!tracks.length){ appendLog('No hay pistas cargadas.'); return; }
      bingoRunning = true;
      bingoPaused = false;
    
      const order = shuffle(tracks);
    
      for (const t of order){
        // Si venimos de una reanudación y currentTrack coincide, reutiliza currentSeg/remainingMs
        currentTrack = t;
        const seg = segments[t.id] || { start:45, end:60 }; // 15s por defecto
        currentSeg = seg;
    
        const startSec = seg.start, endSec = seg.end;
        const durationMs = (endSec - startSec) * 1000;
    
        appendLog(`▶ ${t.name} — ${t.artists} [${startSec}s → ${endSec}s]`);
    
        // Play en el dispositivo elegido
        await playTrackUri(t.uri);
        await sleep(1200);
        await seekPosition(startSec * 1000);
    
        // Reproducir fragmento (pausable)
        remainingMs = durationMs;
        await sleepPausable(durationMs);
    
        // Pausa al final del fragmento
        const pauseUrl = `https://api.spotify.com/v1/me/player/pause?device_id=${deviceId}`;
        await tryFetch(pauseUrl, { method:'PUT', headers:{ 'Authorization': `Bearer ${token}` } }, 2, 500);
    
        // Registrar log
        logRows.push({ ts:new Date().toISOString(), track:t.name, artist:t.artists, start:startSec, end:endSec });
    
        // Si el usuario ha pulsado “Pausar” y desea detener el bingo por completo, sal
        if (!bingoRunning) {
          appendLog('Bingo detenido.');
          return;
        }
      }
      appendLog('Bingo completado.');
    }


    function downloadLogCsv(){
      const header = 'timestamp,track,artist,start_sec,end_sec\n';
      const rows = logRows.map(r => `${r.ts},"${r.track.replace(/"/g,'""')}","${r.artist.replace(/"/g,'""')}",${r.start},${r.end}`).join('\n');
      const blob = new Blob([header+rows], { type:'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='bingo_log.csv'; a.click();
      URL.revokeObjectURL(url);
    }

    /***********
     * EVENTOS *
     ***********/
    document.getElementById('loginBtn').onclick = startLogin;
    document.getElementById('loadPlaylistBtn').onclick = () => loadPlaylist().catch(e => appendLog(e.message));
    document.getElementById('startBingoBtn').onclick = () => startBingo().catch(e => appendLog(e.message));

    document.getElementById('pauseBingoBtn').onclick = async () => {
      if (!bingoRunning) { appendLog('El bingo no está en ejecución.'); return; }
      bingoPaused = true;
      pauseStartedAt = Date.now();
    
      if (deviceId) {
        const pauseUrl = `https://api.spotify.com/v1/me/player/pause?device_id=${deviceId}`;
        await tryFetch(pauseUrl, { method:'PUT', headers:{ 'Authorization': `Bearer ${token}` } }, 2, 500);
      }
      appendLog('Bingo en pausa.');
    };

    document.getElementById('resumeBingoBtn').onclick = async () => {
      if (!bingoRunning) { appendLog('El bingo no está en ejecución.'); return; }
      if (!currentTrack || !currentSeg) { appendLog('No hay pista activa para reanudar.'); return; }
    
      // Calcular dónde retomar
      const segEndMs = currentSeg.end * 1000;
      let resumeMs = Math.max(0, segEndMs - remainingMs);
    
      // Si por cualquier motivo remainingMs no está bien, cae al inicio del segmento
      if (!Number.isFinite(resumeMs)) resumeMs = currentSeg.start * 1000;
    
      // Transferir/activar el dispositivo y retomar
      await transferPlayback(true);
      await playTrackUri(currentTrack.uri);
      await sleep(600);
      await seekPosition(resumeMs);
    
      bingoPaused = false;
      appendLog(`Reanudado: ${currentTrack.name} en ${(resumeMs/1000).toFixed(1)}s`);
    };

    document.getElementById('stopBingoBtn').onclick = async () => {
      if (!bingoRunning) { appendLog('El bingo ya está detenido.'); return; }
      bingoRunning = false;
      bingoPaused = false;
      
    document.getElementById('genCsvBtn').onclick = () => {
      if (!tracks?.length) { appendLog('Carga primero la playlist para generar el CSV.'); return; }
    
      // Genera un fragmento aleatorio de 15s válido para cada pista
      const rows = [];
      for (const t of tracks) {
        const durSec = Math.floor((t.duration_ms || 0) / 1000);
    
        // Ventana segura para 15s:
        // - si la canción dura < 40s, ponemos 0→15 (por seguridad)
        // - si dura >= 40s, escogemos al azar entre 5s y (dur-15-5)
        let start = 0, end = 15;
        if (durSec >= 40) {
          const minStart = 5;
          const maxStart = Math.max(minStart, durSec - 15 - 5);
          start = Math.floor(Math.random() * (maxStart - minStart + 1)) + minStart;
          end = start + 15;
        }
    
        rows.push(`${t.id},${start},${end}`);
      }

      
      document.getElementById('validarCsvBtn').onclick = () => {
        if (!tracks?.length) { appendLog('Carga primero la playlist.'); return; }
        const trackIds = new Set(tracks.map(t => t.id));
        const segIds = Object.keys(segments);
        const matched = segIds.filter(id => trackIds.has(id));
        const missing = tracks.filter(t => !segments[t.id]).map(t => t.id);
        appendLog(`CSV: ${segIds.length} segmentos; coinciden: ${matched.length}; sin segmento: ${missing.length}`);
        if (missing.length) appendLog(`IDs sin segmento: ${missing.slice(0,10).join(', ')}...`);
      };


  const csv = 'track_id,start_sec,end_sec\n' + rows.join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'segmentos_aleatorios.csv'; a.click();
  URL.revokeObjectURL(url);

  appendLog(`CSV generado: ${tracks.length} filas (15s aleatorios por pista).`);
};

    
      // Pausa la reproducción por si quedaba algo sonando
      if (deviceId) {
        const pauseUrl = `https://api.spotify.com/v1/me/player/pause?device_id=${deviceId}`;
        await tryFetch(pauseUrl, { method:'PUT', headers:{ 'Authorization': `Bearer ${token}` } }, 2, 500);
      }
    
      // Limpia estado
      currentTrack = null;
      currentSeg = null;
      remainingMs = 0;
      pauseStartedAt = null;
    
      appendLog('Bingo detenido y reseteado.');
    };

    document.getElementById('downloadLogBtn').onclick = downloadLogCsv;

    document.getElementById('activateAudioBtn').onclick = async () => {
      try { if (player && player.activateElement) await player.activateElement(); await player.setVolume(1.0); appendLog('Audio activado.'); }
      catch(e){ appendLog('activateElement/setVolume error: ' + e.message); }
    };
    document.getElementById('useThisDeviceBtn').onclick = async () => { await transferPlayback(true); appendLog('Este dispositivo fijado como destino.'); };
    document.getElementById('listarDevicesBtn').onclick = async () => { try { await listarDispositivos(); } catch(e){ appendLog(e.message); } };

    // Pre-rellenar
    document.getElementById('clientId').value = DEFAULT_CLIENT_ID;
    document.getElementById('redirectUri').value = DEFAULT_REDIRECT_URI;

    // 1) Canjea token si venimos de OAuth
    handleRedirectBack().catch(e => appendLog(e.message));
  </script>

  <!-- Cargar el SDK DESPUÉS de definir el callback -->
  <script src="https://sdk.scdn.co/r.js</script>
</body>
</html>







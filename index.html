<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <title>Bingo musical (Spotify Web Playback SDK + PKCE)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 20px; }
    h1 { margin-top: 0; }
    label { display:block; margin:6px 0; }
    input { width: 100%; max-width: 560px; padding:8px; }
    button { padding: 10px 16px; margin: 8px 6px 8px 0; }
    pre { background:#f5f5f5; padding:10px; max-height:300px; overflow:auto; white-space:pre-wrap; }
    small { color:#555; }
  </style>
</head>
<body>
  <h1>Bingo musical</h1>

  <label>Client ID de Spotify:
    <input id="clientId" placeholder="tu_client_id">
  </label>
  <label>Redirect URI:
    <input id="redirectUri" placeholder="https://jlmarest.github.io/Bingo-musical/">
  </label>
  <button id="loginBtn">Iniciar sesión en Spotify</button>

  <label>Playlist ID (spotify:playlist:... o URL):
    <input id="playlistId" placeholder="https://open.spotify.com/playlist/XXXXXXXXXXXXXX">
  </label>
  <input type="file" id="segmentsCsv" accept=".csv"/>
  <small>(Opcional) CSV con segmentos: track_id,start_sec,end_sec</small>
  <div>
    <button id="loadPlaylistBtn">Cargar playlist</button>
    <button id="startBingoBtn">Empezar bingo</button>
    <button id="downloadLogBtn">Descargar log (CSV)</button>
  </div>

  <div>
    <button id="activateAudioBtn">Activar audio (si no suena)</button>
    <button id="useThisDeviceBtn">Usar este dispositivo</button>
    <button id="listarDevicesBtn">Listar dispositivos</button>
  </div>

  <pre id="log"></pre>

  <script>
    /**********************
     * CONFIG POR DEFECTO *
     **********************/
    const DEFAULT_CLIENT_ID = 'f19b2716d1bb46ba98f7ff7c5bf3656c';  // puedes cambiarlo si quieres
    const DEFAULT_REDIRECT_URI = 'https://jlmarest.github.io/Bingo-musical/'; // debe coincidir 1:1 con Spotify App
    const PLAYER_NAME = 'Bingo musical';

    /*****************
     * ESTADO GLOBAL *
     *****************/
    let token = null;
    let refreshToken = null;
    let tokenExpiry = 0;
    let deviceId = null;
    let player = null;
    let tracks = [];
    let segments = {};
    let logRows = [];

    const SCOPES = [
      'streaming',
      'user-read-email',
      'user-read-private',
      'playlist-read-private',
      'playlist-read-collaborative',
      'user-modify-playback-state',
      'user-read-playback-state'
    ];

    const logEl = document.getElementById('log');
    function appendLog(msg) { logEl.textContent += msg + "\n"; }
    function getClientId(){ return (document.getElementById('clientId').value.trim() || DEFAULT_CLIENT_ID); }
    function getRedirectUri(){ return (document.getElementById('redirectUri').value.trim() || DEFAULT_REDIRECT_URI); }
    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    /**************
     * PKCE OAuth *
     **************/
    function base64urlencode(arrayBuffer) {
      let str = btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer)));
      return str.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
    }
    async function sha256(plain) {
      const enc = new TextEncoder().encode(plain);
      const digest = await crypto.subtle.digest('SHA-256', enc);
      return digest;
    }
    function randomString(len=64){
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let out = '';
      const arr = new Uint32Array(len);
      crypto.getRandomValues(arr);
      for (let i=0;i<len;i++) out += chars[arr[i] % chars.length];
      return out;
    }
    function saveAuthState(obj){ sessionStorage.setItem('auth_state', JSON.stringify(obj)); }
    function readAuthState(){ try{ return JSON.parse(sessionStorage.getItem('auth_state')||'{}'); }catch{ return {} } }

    async function ensureTokenValid(){
      if (!token) return;
      const now = Date.now();
      if (now < tokenExpiry - 5000) return;
      if (!refreshToken) return;
      const params = new URLSearchParams();
      params.set('grant_type','refresh_token');
      params.set('refresh_token', refreshToken);
      params.set('client_id', getClientId());
      const res = await fetch('https://accounts.spotify.com/api/token', {
        method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
        body: params.toString()
      });
      if (!res.ok){ appendLog('Error al refrescar token: ' + res.status); return; }
      const data = await res.json();
      token = data.access_token;
      tokenExpiry = Date.now() + (data.expires_in * 1000);
      saveAuthState({ token, refreshToken, tokenExpiry });
      appendLog('Token renovado.');
    }

    async function startLogin(){
      const clientId = getClientId();
      const redirectUri = getRedirectUri();
      const codeVerifier = randomString(64);
      const codeChallenge = base64urlencode(await sha256(codeVerifier));
      const state = randomString(16);
      saveAuthState({ codeVerifier, state });
      const params = new URLSearchParams({
        client_id: clientId,
        response_type: 'code',
        redirect_uri: redirectUri,
        code_challenge_method: 'S256',
        code_challenge: codeChallenge,
        scope: SCOPES.join(' '),
        state
      });
      window.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
    }

    async function handleRedirectBack(){
      const url = new URL(window.location.href);
      const code = url.searchParams.get('code');
      const returnedState = url.searchParams.get('state');
      const error = url.searchParams.get('error');
      if (error){ appendLog('Error OAuth: '+error); return; }
      if (!code) return;

      const { codeVerifier, state } = readAuthState();
      if (!codeVerifier || state !== returnedState){ appendLog('Estado OAuth inválido.'); return; }

      const params = new URLSearchParams();
      params.set('grant_type','authorization_code');
      params.set('code', code);
      params.set('redirect_uri', getRedirectUri());
      params.set('client_id', getClientId());
      params.set('code_verifier', codeVerifier);

      const res = await fetch('https://accounts.spotify.com/api/token', {
        method:'POST', headers:{ 'Content-Type':'application/x-www-form-urlencoded' },
        body: params.toString()
      });
      if (!res.ok){ appendLog('Error token endpoint: '+res.status); return; }

      const data = await res.json();
      token = data.access_token;
      refreshToken = data.refresh_token || null;
      tokenExpiry = Date.now() + (data.expires_in * 1000);
      saveAuthState({ token, refreshToken, tokenExpiry });
      appendLog('Autenticado.');

      // Limpia la query para evitar repetir el canje al refrescar
      history.replaceState({}, document.title, window.location.pathname);
    }

    /**********************
     * CARGA DEL SDK (OK) *
     **********************/
    // Definir el callback ANTES de cargar el script del SDK
    window.onSpotifyWebPlaybackSDKReady = () => {
      appendLog('SDK cargado.');
      initPlayer();
    };

    function initPlayer(){
      if (!token){ appendLog('Aún no hay token; inicia sesión primero.'); return; }
      player = new Spotify.Player({
        name: PLAYER_NAME,
        getOAuthToken: async cb => { await ensureTokenValid(); cb(token); },
        volume: 1.0
      });

      player.addListener('ready', async ({ device_id }) => {
        deviceId = device_id;
        appendLog('Dispositivo listo: ' + deviceId);
        try { if (player.activateElement) await player.activateElement(); } catch {}
        await transferPlayback(true); // fija este dispositivo como destino
        try { await listarDispositivos(); } catch {}
      });

      player.addListener('not_ready', ({ device_id }) => {
        appendLog('Dispositivo offline: ' + device_id);
        if (deviceId === device_id) deviceId = null;
      });

      player.addListener('initialization_error', ({ message }) => appendLog('Init error: ' + message));
      player.addListener('authentication_error', ({ message }) => appendLog('Auth error: ' + message));
      player.addListener('account_error', ({ message }) => appendLog('Account error: ' + message));
      player.addListener('playback_error', ({ message }) => appendLog('Playback error: ' + message));

      player.addListener('player_state_changed', (state) => {
        if (!state){ appendLog('Estado: null (SDK no activo)'); return; }
        const t = state.track_window.current_track;
        appendLog(`Estado: ${state.paused ? 'Pausa':'Reproduciendo'} — ${t?.name ?? '(sin pista)'}`);
      });

      player.connect().then(ok => appendLog('player.connect() => ' + ok));
    }

    /*****************
     * API genérica  *
     *****************/
    async function api(path, method='GET', body=null) {
      await ensureTokenValid();
      const res = await fetch(
        path.startsWith('http') ? path : `https://api.spotify.com/v1/${path}`,
        { method, headers:{ 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: body ? JSON.stringify(body) : null }
      );
      if (!res.ok) throw new Error(`${path} => ${res.status}`);
      return res.json();
    }

    async function tryFetch(url, options, retries=3, backoff=500){
      for (let i=0;i<retries;i++){
        try{
          const res = await fetch(url, options);
          if (res.ok) return res;
          appendLog(`Fetch fallo (${res.status}) en ${url}, intento ${i+1}/${retries}`);
        }catch(e){
          appendLog(`Fetch error en ${url}: ${e.message} (intento ${i+1}/${retries})`);
        }
        await sleep(backoff*(i+1));
      }
      throw new Error('Failed to fetch: ' + url);
    }

    async function listarDispositivos(){
      const data = await api('me/player/devices');
      const resumen = data.devices.map(d => `${d.name} [${d.type}] activo=${d.is_active} (id=${d.id})`).join(' | ');
      appendLog('Dispositivos: ' + resumen);
      return data.devices;
    }


    // Elige el mejor dispositivo disponible: primero SDK (si existiera),
    // si no, Web Player (Chrome/Edge), si no, cualquiera activo; si no, el primero.
    async function chooseBestDevice() {
      await ensureTokenValid();
      const data = await api('me/player/devices');
      const devices = data.devices || [];

      // 1) Preferir el dispositivo del SDK (si llegara a existir)
      let d = devices.find(x => x.name === PLAYER_NAME);

      // 2) Si no hay SDK, preferir Web Player del navegador
      if (!d) {
        d = devices.find(x => /Web Player/i.test(x.name)); // Chrome o Edge
      }

      // 3) Si no hay Web Player, elegir uno activo
      if (!d) {
        d = devices.find(x => x.is_active);
      }

      // 4) Si no hay ninguno activo, elegir el primero disponible
      if (!d) {
        d = devices[0];
      }

      if (!d) {
        appendLog('No hay dispositivos disponibles en tu cuenta.');
        return false;
      }

      deviceId = d.id;
      appendLog(`Destino elegido: ${d.name} [${d.type}] activo=${d.is_active} (id=${d.id})`);
      return true;
    }

    async function transferPlayback(playNow = false) {
      await ensureTokenValid();

      // Si no tenemos deviceId, elegimos uno (idealmente el Web Player)
      if (!deviceId) {
        const ok = await chooseBestDevice();
        if (!ok) { appendLog('Transfer cancelado: sin deviceId.'); return; }
      }

      const res = await fetch('https://api.spotify.com/v1/me/player', {
        method: 'PUT',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ device_ids: [deviceId], play: !!playNow })
      });

      if (res.ok) {
        appendLog('Playback transferido al dispositivo elegido.');
      } else {
        appendLog('Transfer playback error: ' + res.status);
      }
    }


    async function isSdkActive(){
      try { const st = await player.getCurrentState(); return !!st; } catch { return false; }
    }

    async function playTrackUri(uri) {
      await ensureTokenValid();
      // Asegurar que tenemos destino y que está activo
      if (!deviceId) { const ok = await chooseBestDevice(); if (!ok) return; }
      await tryFetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
        method: 'PUT',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: JSON.stringify({ uris: [uri] })
      }, 3, 500);
    }

    async function seekPosition(ms) {
      await ensureTokenValid();
      if (!deviceId) { const ok = await chooseBestDevice(); if (!ok) return; }
      await tryFetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${ms}&device_id=${deviceId}`, {
        method: 'PUT',
        headers: { 'Authorization': `Bearer ${token}` }
      }, 2, 500);
    }

    function parsePlaylistId(input){
      const v = (input||'').trim();
      try{
        if (v.includes('playlist')){
          const u = new URL(v);
          const parts = u.pathname.split('/');
          const idx = parts.findIndex(p => p==='playlist');
          if (idx>=0 && parts[idx+1]) return parts[idx+1];
        }
      }catch{}
      return v;
    }

    async function loadPlaylist(){
      if (!token){ appendLog('No estás autenticado.'); return; }
      tracks = [];
      const pid = parsePlaylistId(document.getElementById('playlistId').value);
      appendLog('Cargando playlist: ' + pid);

      let url = `https://api.spotify.com/v1/playlists/${pid}/tracks?fields=items(track(id,name,artists(name),uri)),next&limit=100`;
      while (url){
        await ensureTokenValid();
        const res = await fetch(url, { headers:{ 'Authorization': `Bearer ${token}` } });
        if (!res.ok) throw new Error(`API ${url} => ${res.status}`);
        const data = await res.json();
        for (const item of data.items){
          if (item.track && item.track.id){
            tracks.push({
              id: item.track.id,
              name: item.track.name,
              artists: item.track.artists.map(a=>a.name).join(', '),
              uri: `spotify:track:${item.track.id}`
            });
          }
        }
        url = data.next;
      }
      appendLog(`Total pistas: ${tracks.length}`);

      const file = document.getElementById('segmentsCsv').files[0];
      segments = {};
      if (file){
        const text = await file.text();
        for (const line of text.split(/\r?\n/)){
          const [tid, start, end] = line.split(',');
          if (tid && start && end) segments[tid.trim()] = { start:+start, end:+end };
        }
        appendLog(`Segmentos cargados: ${Object.keys(segments).length}`);
      }else{
        appendLog('Sin CSV: se usarán fragmentos simulados (15s desde 45s).');
      }

      await transferPlayback(true);
    }

    function shuffle(a){
      const r = a.slice();
      for (let i=r.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [r[i],r[j]]=[r[j],r[i]]; }
      return r;
    }

    async function startBingo(){
      if (!tracks.length){ appendLog('No hay pistas cargadas.'); return; }
      const order = shuffle(tracks);

      for (const t of order){
        const seg = segments[t.id] || { start:45, end:60 }; // 15s desde 00:45
        const startSec = seg.start, endSec = seg.end;

        appendLog(`▶ ${t.name} — ${t.artists} [${startSec}s → ${endSec}s]`);
        await playTrackUri(t.uri);
        await sleep(1200);
        await seekPosition(startSec * 1000);

        await sleep((endSec - startSec) * 1000);

        const useSDK = await isSdkActive() && !!deviceId;

        const pauseUrl = `https://api.spotify.com/v1/me/player/pause?device_id=${deviceId}`;
        await tryFetch(pauseUrl, { method: 'PUT', headers: { 'Authorization': `Bearer ${token}` } }, 2, 500);


        logRows.push({ ts:new Date().toISOString(), track:t.name, artist:t.artists, start:startSec, end:endSec });
      }
      appendLog('Bingo completado.');
    }

    function downloadLogCsv(){
      const header = 'timestamp,track,artist,start_sec,end_sec\n';
      const rows = logRows.map(r => `${r.ts},"${r.track.replace(/"/g,'""')}","${r.artist.replace(/"/g,'""')}",${r.start},${r.end}`).join('\n');
      const blob = new Blob([header+rows], { type:'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='bingo_log.csv'; a.click();
      URL.revokeObjectURL(url);
    }

    /***********
     * EVENTOS *
     ***********/
    document.getElementById('loginBtn').onclick = startLogin;
    document.getElementById('loadPlaylistBtn').onclick = () => loadPlaylist().catch(e => appendLog(e.message));
    document.getElementById('startBingoBtn').onclick = () => startBingo().catch(e => appendLog(e.message));
    document.getElementById('downloadLogBtn').onclick = downloadLogCsv;

    document.getElementById('activateAudioBtn').onclick = async () => {
      try { if (player && player.activateElement) await player.activateElement(); await player.setVolume(1.0); appendLog('Audio activado.'); }
      catch(e){ appendLog('activateElement/setVolume error: ' + e.message); }
    };
    document.getElementById('useThisDeviceBtn').onclick = async () => { await transferPlayback(true); appendLog('Este dispositivo fijado como destino.'); };
    document.getElementById('listarDevicesBtn').onclick = async () => { try { await listarDispositivos(); } catch(e){ appendLog(e.message); } };

    // Pre-rellenar
    document.getElementById('clientId').value = DEFAULT_CLIENT_ID;
    document.getElementById('redirectUri').value = DEFAULT_REDIRECT_URI;

    // 1) Canjea token si venimos de OAuth
    handleRedirectBack().catch(e => appendLog(e.message));
  </script>

  <!-- Cargar el SDK DESPUÉS de definir el callback -->
  <script src="https://sdk.scdn.co/r.js</script>
</body>
</html>

